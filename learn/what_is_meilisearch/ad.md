---

sidebarDepth: 2

---

# 数据结构(408)

## 数据结构

定义：数据结构是相互之间存在一种或多种特定关系的数据元素的集合。

数据结构包括三方面的内容：逻辑结构、存储结构和数据的运算。

### 逻辑结构

逻辑结构分为线性结构和非线性结构，线性表是典型的线性结构；集合、树和图是典型的非线性结构。

<img src="https://picture.yan-test.asia/数据的逻辑结构分类图.jpg" alt="数据的逻辑结构分类" style="zoom: 50%;" />

### 存储结构

定义：数据结构在计算机中的表示(又称映像)，也称物理结构。

数据的存储结构主要有顺序存储、链式存储、索引存储和散列存储。

线性表可用顺序存储或链式存储。用顺序存储时，插入或删除元素平均要移动近一半的元素，时间复杂度为$O(n)$；用链式存储时， 插入或删除的时间复杂度都是$O(1)$。

### 数据的运算

施加在数据上的运算包括运算的定义和实现。

<img src="https://picture.yan-test.asia/数据的运算.png" alt="数据的运算" style="zoom: 33%;" />

### 例子

顺序表、哈希表和单链表是三种不同的数据结构，既描述逻辑结构，又描述存储结构和数据运算。

对于两种不同的数据结构，它们的逻辑结构和物理结构完全有可能相同。比如二叉树和二叉排序树，二叉排序树可以采用二叉树的辑结构和物理结构，但它们运算的定义是不同的，以查找结点为例，二叉树的时间复杂度为O(n)，而二叉排序树的时间复杂度为$O(\log_2n)$。

## 算法

定义：算法(Algorithm)是对特定问题求解步骤的一种描述。

算法效率的度量是通过时间复杂度和空间复杂度来描述的。

### 时间复杂度

定义：设$n$为算法问题的规模，$f(n)$为采用算法中所有语句被重复执行的次数，则算法的时间复杂度记为$T(n) = O(f(n))$，$O$表示$f(n)$的数量级函数。

### 空间复杂度

定义：设$n$为算法问题的规模，$g(n)$为采用算法所耗费的存储空间，则算法的空间复杂度记为$S(n) = O(g(n))$，$O$表示$g(n)$的数量级函数。

## 线性表

定义：线性表是具有相同数据类型的$n(n \geq 0)$个数据元素(由数据项组成)的有限序列。

特点：

* 表中元素的数据类型相同。

* 表中元素有先后次序。

线性表是一种逻辑结构，表示元素之间一对一的相邻关系。顺序表和链表是指存储结构。

### 顺序表

定义：线性表的顺序存储称为顺序表。

顺序表是用一组地址连续的存储单元依次存储线性表中的数据元素，从而使得逻辑上相邻的两个元素在物理位置上也相邻。

特点：

* 表中元素的逻辑顺序与其物理顺序相同。

* 表中元素可以随机存取。

* 随机访问，即通过首地址和元素序号可在时间$O(1)$内找到指定的元素。

### 链表

定义：线性表的链式存储称为链表。

链式存储是非随机存取的存储结构，即元素离散地分布在存储空间中，查找某个特定的结点时，需要从表头开始遍历， 依次查找。

### 顺序储存和链式储存

顺序存储：把逻辑上相邻的元素存储在物理位置上也相邻的存储单元中， 元素之间的关系由存储单元的邻接关系来体现。

链式存储：不要求逻辑上相邻的元素在物理位置上也相邻，借助指示元素存储地址的指针来表示元素之间的逻辑关系。

#### 逻辑结构与物理结构

采用顺序存储时，逻辑上相邻的元素，对应的物理存储位置也相邻。而采用链式存储时，逻辑上相邻的元素，物理存储位置不一定相邻，对应的逻辑关系是通过指针链接来表示的。

#### 查找、插入和删除操作

对于按值查找，顺序表无序时，两者的时间复杂度均为$O(n)$；顺序表有序时，可采用折半查找，此时的时间复杂度为$O(\log_2n)$。

对于按序号查找，顺序表支持随机访问，时间复杂度仅为$O(1)$，而链表的平均时间复杂度为$O(n)$。顺序表的插入、删除操作，平均需要移动半个表长的元素。链表的插入、删除操作，只需修改相关结点的指针域即可。

#### 选择

频繁进行插入、删除操作的线性表宜选择链式存储。

### 栈

定义：栈（Stack）是只允许在一端进行插入或删除操作的线性表。

### 队列

定义：队列(Queue)是只允许一端进行插入，而在另一端进行删除的线性表。

### 数组

定义：数组是由$n(n \geq 1)$个相同类型的数据元素构成的有限序列。

数组与线性表的关系：数组是线性表的推广。

### 字符串

定义：字符串是由零个或多个字符组成的有限序列。

字符串是一种特殊的线性表，它们主要的区别在于字符串的数据对象限定为字符集。

#### 模式匹配

定义：子串的定位操作通常称为字符串的模式匹配。

## 树

### 树的定义

树是$n(n \geq 0)$个结点的有限集。当$n = 0$时，称为空树。任意一棵非空树应满足：

* 有且仅有一个特定的称为根的结点。
* 当$n \geq 1$时，其余结点可分为$m(m > 0)$个互不相交的有限集$T_1,T_2,$···$,T_m$，其中每个集合本身又是一棵树，并且称为根的子树。

树的定义是递归的，即在树的定义中又用到了其自身。

<img src="https://picture.yan-test.asia/%E6%A0%91.png" alt="树" style="zoom: 25%;" />

### 结点的度

树中一个结点的孩子个数称为该结点的度。

### 树的度

树中最大的结点的度称为树的度。如结点B的度为2，结点D的度为3，树的度为3。

### 树的性质

1 ） 树中的结点数等于所有结点的度数之和加1 。
2 ） 度为$m$的树中第$i$层上至多有  $m^{i-1}$个结点($i \geq 1$)。
3 ） 高度为$h$ 的 $m$ 叉树至多有$(m^h-1)/(m-1)$ 个结点。
4 ） 具有$n$个结点的$m$叉树的最小高度为 $[\log_m(n(m-1)+1)]$。

## 二叉树

### 二叉树的定义

二叉树是$n(n \geq 0)$个结点的有限集，当$n = 0$时，称为空二叉树。任意一棵非空二叉树应满足：

* 有且仅有一个特定的称为根的结点。
* 由根、根的左子树和右子树组成。
* 根的左子树和右子树互不相交。
* 根的左子树和右子树又分别是一棵二叉树。

二叉树不是树的特殊情形，二叉树的结点有左、右之分。

### 满二叉树

定义：一棵高度为$h$，且含有$2^h-1$个结点的二叉树称为满二叉树。

<img src="https://picture.yan-test.asia/满二叉树.png" alt="树" style="zoom: 25%;" />

满二叉树的每层都含有最多的结点。

### 完全二叉树

定义：高度为$h$、有$n$个结点的二叉树，当且仅当其每个结点都与高度为$h$的满二叉树中编号为$1-n$的结点一一对应时，称为完全二叉树。

<img src="https://picture.yan-test.asia/完全二叉树.jpg" alt="树" style="zoom: 25%;" />

### 二叉排序树

定义：左子树上所有结点的关键字均小于根结点的关键字；右子树上的所有结点的关键字均大于根结点的关键字；左子树和右子树又各是一棵二叉排序树。

### 平衡二叉树

定义：树上任意一个结点的左子树和右子树的深度之差不超过1。

平衡二叉树(Balanced Binary Tree)也称为AVL树。

### 二叉树的性质

1 ） 非空二叉树上的叶结点数等于度为2的结点数加1,即$n_0=n_2+1$。

2 ） 非空二叉树上第$k$层上至多有$2^{k-1}$个结点$(k\geq1)$。

3 ） 高度为$h$的二叉树至多有$2^{h-1}$个结点$(h\geq1)$。

### 二叉树的遍历

1. 前序遍历：先访问根结点然后遍历左子树，最后遍历右子树。

2. 中序遍历：先遍历左子树，然后访问根结点，最后遍历右子树。

3. 后序遍历：先遍历左子树，然后遍历右子树，最后访问根结点。

4. 层序遍历：一层一层地遍历

## 图

### 图的定义

图$G$由顶点集$V$和边集$E$组成，记为$G=(V,E)$，其中$V(G)$表示图$G$中顶点的有限非空集；$E(G)$表示图$G$中顶点之间的关系（边）集合。若$V=${$v_1,v_2,$···$,v_n$}，则用$|V|$表示图$G$中顶点的个数，$E=${$(u,v)|u\in V,v\in V$}，用$|E|$表示图$G$中边的条数。

### 广度优先搜索

广度优先搜索索(Breadth-First-Search, BFS)类似于二叉树的层序遍历算法。

### 深度优先搜索

深度优先搜索索(Depth-First-Search, DFS)类似于二叉树的先序遍历算法。

## 查找

查找：在数据集合中寻找满足某种条件的数据元素的过程。

查找表：用于查找的数据集合。

关键字：数据元素的唯一标识。

平均查找长度：查找过程中进行关键字的比较次数的平均值。

### 折半查找（二分查找）

折半查找（二分查找）适用于有序的顺序表。 

### 分块查找

分块查找吸取了顺序查找和折半查找的优点。 

适用情景：查找表分为若干子块，块内的元素可以无序，但块间的元素是有序的，即第一个块中的最大关键字小于第二个块中的所有记录的关键字，第二个块中的最大关键字小于第三个块中的所有记录的关键字，以此类推。

### 散列表

散列表：可以根据关键字直接进行访问的数据结构。

散列函数：一个把查找表中的关键字映射成该关键字对应的地址的函数，记为$Hash (key) = Addr $(这里的地址可以是数组下标、索引或内存地址等)。

散列冲突：散列函数把两个或两个以上的不同关键字映射到同一地址。

## 排序

排序就是重新排列表中的元素，使表中的元素满足按关键字有序的过程。

### 算法的稳定性

若待排序表中有两个元素$R_i$和$R_j$，其对应的关键字相同即$key_i=key_j$，且在排序前$R_i$在$R_j$前面，若使用某一排序算法排序后，$R_i$仍然在$R_j$前面，则称这个排序算法是稳定的，否则称排序算法是不稳定的。

### 插入排序

将一个待排序的记录按其关键字大小插入前面已排好序的子序列，直到全部记录插入完成。

直接插入排序：将一个待排序的记录插入到已排好的有序表中，从而得到一个新的、记录数量增1的有序表。

折半插入排序：对插入算法的一种改进，不再按顺序依次寻找插入点，而是采用折半查找的方法来加快寻找插入点的速度。

希尔排序：对插入算法的一种改进，多次分组插入排序。组内使用直接插入排序算法排序，首次分组数量为有序表的长度除以二取整，之后每次分组数量都是前一次分组数量除以二取整。

### 交换排序

冒泡排序：从后往前（或从前往后）两两比较相邻元素的值，将小的元素排前面（后面），直到关键字最小的元素在前面（后面）。下一趟比较时，前一趟确定的最小元素不再参与比较，这样最多做$n-1$趟冒泡就能把所有元素排好序。 

快速排序：设定一个分界值将数组分成左右两部分，左边部分中各元素都小于（大于或等于）分界值，而右边部分中各元素都大于或等于（小于）分界值，左右两部分又分别设置分界值。以此类推，直到取不到分界值。

### 选择排序

简单选择排序：第一次从待排序的数据元素中选出最小（或最大）的一个元素，存放在序列的起始位置，然后再从剩余的未排序元素中寻找到最小（大）元素，然后放到已排序的序列的末尾。以此类推，直到全部待排序的数据元素的个数为零。

堆排序：利用堆这种数据结构所设计的一种排序算法。

#### 堆

* 是一棵完全二叉树。
* 每个节点的值都大于或等于其左右孩子节点的值，为最大堆；反之为最小堆。

### 归并排序

将两个或两个以上的有序表合并成一个新的有序表。

#### 二路归并

假定待排序表含有$n$个记录，则可将其视为$n$个有序的子表， 每个子表的长度为1，然后两两归并，得到$[n/2]$个长度为2或1的有序表；继续两两归并……如此重复，直到合并成一个长度为$n$的有序表为止，这种排序方法称为二路归并排序。

### 基数排序

将所有待比较数值统一为同样的数位长度，数位较短的数前面补零。然后，从最低位开始，依次进行一次排序。这样从最低位排序一直到最高位排序完成以后，数列就变成一个有序序列。

### 内部排序算法的比较

时间复杂度：简单选择排序、直接插入排序和冒泡排序平均情况下的时间复杂度都为$O(n^2)$，但直接插入排序和冒泡排序最好情况下的时间复杂度可以达到$O(n)$，而简单选择排序则与序列的初始状态无关。

空间复杂度：插入排序、希尔排序、冒泡排序、简单选择排序和堆排序都仅需借助常数个辅助空间。快速排序需要借助一个递归工作栈，平均大小为$O(\log_2n)$，在最坏情况下可能会增长到$O(n)$。二路归并排序在合并操作中需要借助较多的辅助空间用于元素复制，大小为$O(n)$。

稳定性：插入排序、冒泡排序、归并排序和基数排序是稳定的排序方法，希尔排序、快速排序、简单选择排序和堆排序都是不稳定的排序方法。
