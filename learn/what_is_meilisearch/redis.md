---

sidebarDepth: 2

---

# Redis

## 相关概念

### 键值型

键值型是指数据是以key、value对的形式存储，value的形式多种多样，可以是字符串、数值、json。

### Nosql

**NoSql**可以翻译做Not Only Sql，是相对于传统关系型数据库而言，有很大差异的一种特殊的数据库，因此也称之为**非关系型数据库**。

### Redis

Redis全称是**Re**mote  **D**ictionary **S**erver，是一个基于内存的键值型NoSQL数据库。

Redis是典型的key-value数据库，key一般是字符串，而value包含很多不同的数据类型：

![数据类型](https://picture.yan-test.asia/8tli2o9.png)

#### String类型

在Redis中String类型指的是存储类型，其value是字符串，不过根据字符串的格式不同，又可以分为3类：

* string：普通字符串
* int：整数类型，可以做自增、自减操作
* float：浮点类型，可以做自增、自减操作

底层都是字节数组形式存储，只不过是编码方式不同。字符串类型的最大空间不能超过512m。

#### Hash类型

Hash类型也叫散列，其value是一个无序字典，类似于Java中的HashMap结构。

String结构是将对象序列化为JSON字符串后存储，当需要修改对象某个字段时很不方便。

Hash结构可以将对象中的每个字段独立存储，可以针对单个字段做CRUD。

#### List类型

Redis中的List类型与Java中的LinkedList类似，可以看做是一个双向链表结构。既可以支持正向检索和也可以支持反向检索。

特征也与LinkedList类似：

* 有序
* 元素可以重复
* 插入和删除快
* 查询速度一般

常用来存储一个有序数据，例如：朋友圈点赞列表，评论列表等。

#### Set类型

Redis的Set结构与Java中的HashSet类似，可以看做是一个value为null的HashMap。因为也是一个hash表，因此具备与HashSet类似的特征：

* 无序

* 元素不可重复

* 查找快

* 支持交集、并集、差集等功能

#### SortedSet类型

SortedSet是一个可排序的set集合，它的每一个元素都带有一个score属性，可以基于score属性对元素排序，底层的实现是一个跳表（SkipList）加 hash表。

SortedSet具备下列特性：

* 可排序
* 元素不重复
* 查询速度快

因为SortedSet的可排序特性，经常被用来实现排行榜这样的功能。

### 缓存

**缓存(**Cache)，就是数据交换的**缓冲区**，俗称的缓存就是**缓冲区内的数据**，一般从数据库中获取存储于本地代码。

```java
例1:Static final ConcurrentHashMap<K,V> map = new ConcurrentHashMap<>(); 本地用于高并发

例2:static final Cache<K,V> USER_CACHE = CacheBuilder.newBuilder().build(); 用于redis等缓存

例3:Static final Map<K,V> map =  new HashMap(); 本地缓存
```

由于其被**Static**修饰，所以随着类的加载而被加载到**内存之中**，作为本地缓存。

缓存数据存储于代码中，而代码运行在内存中，内存的读写性能远高于磁盘，缓存可以大大降低**用户访问并发量带来的**服务器读写压力。

#### 缓存更新策略

内存淘汰：redis自动进行，当redis内存达到咱们设定的max-memery的时候，会自动触发淘汰机制，淘汰掉一些不重要的数据(可以自己设置策略方式)

超时剔除：当我们给redis设置了过期时间ttl之后，redis会将超时的数据进行删除，方便咱们继续使用缓存

主动更新：我们可以手动调用方法把缓存删掉，通常用于解决缓存和数据库不一致问题

#### 数据库缓存不一致

当数据库中数据发生变化，而缓存却没有同步。

解决方案：

Cache Aside Pattern 人工编码方式：缓存调用者在更新完数据库后再去更新缓存

删除缓存还是更新缓存？

更新缓存：每次更新数据库都更新缓存，无效写操作较多

删除缓存：更新数据库时让缓存失效，查询时再更新缓存

#### 缓存穿透

缓存穿透是指客户端请求的数据在缓存中和数据库中都不存在，这样缓存永远不会生效，这些请求都会打到数据库。

#### 缓存雪崩

缓存雪崩是指在同一时段大量的缓存key同时失效或者Redis服务宕机，导致大量请求到达数据库，带来巨大压力。

解决方案：

* 使用 Redis 高可用架构：使用 Redis 集群来保证 Redis 服务不会挂掉
* 给缓存的失效时间，加上一个随机值，避免集体失效

#### 缓存击穿

缓存击穿问题也叫热点Key问题，就是一个被高并发访问并且缓存重建业务较复杂的key突然失效了，无数的请求访问会在瞬间给数据库带来巨大的冲击。

解决方案：

* 存null值
