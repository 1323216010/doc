---

sidebarDepth: 3

---

# 数据库

## 相关概念

我们平时说的MySQL数据库其实是MySQL数据库管理系统。

### 1. SQL分类

#### DDL(Data Definition Language)

数据定义语言，用来定义数据库对象：数据库，表，列等

简单理解就是用来操作数据库，表等

#### DML(Data Manipulation Language)

数据操作语言，用来对数据库中表的数据进行增删改

简单理解就对表中数据进行增删改

#### DQL(Data Query Language)

数据查询语言，用来查询数据库中表的记录(数据)

DQL简单理解就是对数据进行查询操作。从数据库表中查询到我们想要的数据。

#### DCL(Data Control Language)

数据控制语言，用来定义数据库的访问权限和安全级别，及创建用户

DCL简单理解就是对数据库进行权限控制。比如我让某一个数据库表只能让某一个用户进行操作等。

### 2. 约束

* **非空约束： NOT NULL**

  保证列中所有的数据不能有null值。

* **唯一约束：UNIQUE**

  保证列中所有数据各不相同。

* **主键约束：PRIMARY KEY**

  主键约束 = 非空约束 + 唯一约束

* **检查约束： CHECK**

  保证列中的值满足某一条件。

  > MySQL不支持检查约束

* **默认约束： DEFAULT**

  保存数据时，未指定值则采用默认值。

* **外键约束：FOREIGN KEY**

  外键用来让两个表的数据之间建立链接，保证数据的一致性和完整性。

### 3.多表查询

#### 内连接

```sql
-- 隐式内连接
SELECT 字段列表 FROM 表1,表2… WHERE 条件;

-- 显示内连接
SELECT 字段列表 FROM 表1 [INNER] JOIN 表2 ON 条件;
```

#### 外连接

```sql
-- 左外连接
SELECT 字段列表 FROM 表1 LEFT [OUTER] JOIN 表2 ON 条件;

-- 右外连接
SELECT 字段列表 FROM 表1 RIGHT [OUTER] JOIN 表2 ON 条件;
```

#### 子查询

查询中嵌套查询，称嵌套查询为子查询。

### 4. 事务

数据库的事务（Transaction）是一种机制、一个操作序列，包含了==一组数据库操作命令==。

#### 操作命令

* 开启事务

  ```sql
  START TRANSACTION;
  或者  
  BEGIN;
  ```

* 提交事务

  ```sql
  commit;
  ```

* 回滚事务

  ```sql
  rollback;
  ```

#### 事务的四大特征

* 原子性（Atomicity）: 事务是不可分割的最小操作单位，要么同时成功，要么同时失败
* 一致性（Consistency） :事务完成时，必须使所有的数据都保持一致状态
* 隔离性（Isolation） :多个事务之间，操作的可见性
* 持久性（Durability） :事务一旦提交或回滚，它对数据库中的数据的改变就是永久的

#### 事务的并发问题

* 脏读：一个事务读到另外一个事务还没有提交的数据。
* 不可重复读：一个事务先后读取同一条记录，但两次读取的数据不同，称之为不可重复读。
* 幻读：一个事务按照条件查询数据时，没有对应的数据行，但是在插入数据时，又发现这行数据
  已经存在。

#### 事务隔离级别

| 事务隔离级别                | 脏读 | 不可重复读 | 幻读 |
| --------------------------- | :--- | :--------- | :--- |
| 读未提交(Read uncommitted ) | 是   | 是         | 是   |
| 读已提交(Read committed)    | 否   | 是         | 是   |
| 可重复读(Repeatable Read)   | 否   | 否         | 是   |
| 串行(Serializable)          | 否   | 否         | 否   |

Mysql默认的是可重复读。

事务隔离级别越高，数据越安全，但是性能越低。

### 5. 索引

索引（Index）是帮助数据库管理系统高效获取数据的数据结构。

文件系统及数据库系统普遍采用B-/+Tree作为索引结构。

索引以索引文件的形式存储的磁盘上，查找过程中就要产生磁盘I/O消耗，要尽量减少查找过程中磁盘I/O的存取次数。

在MySQL中，索引属于存储引擎级别的概念，MyISAM引擎和InnoDB都使用B+Tree作为索引结构。

#### 索引特点

| 优势                                                         | 劣势                                                         |
| ------------------------------------------------------------ | ------------------------------------------------------------ |
| 提高数据检索的效率，降低数据库 的IO成本                      | 索引列也是要占用空间的。                                     |
| 通过索引列对数据进行排序，降低 数据排序的成本，降低CPU的消  耗。 | 索引大大提高了查询效率，同时却也降低更新表的速度， 如对表进行INSERT、UPDATE、DELETE时，效率降低。 |

#### 索引分类

##### 主要分类

| 分类     | 含义                                                  | 特点                       | 关键字   |
| -------- | ----------------------------------------------------- | -------------------------- | -------- |
| 主键索引 | 针对于表中主键创建的索引                              | 默认自动创建 , 只能 有一个 | PRIMARY  |
| 唯一索引 | 避免同一个表中某数据列中的值重复                      | 可以有多个                 | UNIQUE   |
| 常规索引 | 快速定位特定数据                                      | 可以有多个                 |          |
| 全文索引 | 全文索引查找的是文本中的关键词，而不是比 较索引中的值 | 可以有多个                 | FULLTEXT |

##### 存储形式

在InnoDB存储引擎中，根据索引的存储形式，分为以下两种：

| 分类                       | 含义                                                        | 特点                  |
| -------------------------- | ----------------------------------------------------------- | --------------------- |
| 聚集索引 (ClusteredIndex)  | 将数据存储与索引放到了一块，索引结构的叶子 节点保存了行数据 | 必须有 ,而且只 有一个 |
| 二级索引 (Secondary Index) | 将数据与索引分开存储，索引结构的叶子节点关 联的是对应的主键 | 可以存在多个          |

#### 创建索引

```sql
CREATE INDEX index_name ON table_name (column_name);
```

#### 最左前缀法则

如果索引了多列（联合索引），要遵守最左前缀法则。最左前缀法则指的是查询从索引的最左列开始，并且不跳过索引中的列。如果跳跃某一列，索引将会部分失效(后面的字段索引失效)。

#### 范围查询

联合索引中，出现范围查询(>,<)，范围查询右侧的列索引失效。

使用>= 或 <= 时，所有的字段都是走索引的。

#### 索引失效

##### 索引列运算

在索引列上进行运算操作， 索引将失效。

##### 字符串不加引号

字符串类型字段使用时，不加引号，索引将失效。

##### 头部模糊匹配

模糊查询时，%加在关键字之前，索引将失效。

##### or连接条件

or的左右两侧字段都有索引时，索引才会生效。

##### 返回大量数据

MySQL在查询时会评估使用索引的效率与走全表扫描的效率，返回大量数据不
如走全表扫描来的快时，索引将失效。

#### 覆盖索引

覆盖索引是指查询使用了索引，并且需要返回的列，在该索引中已经全部能够找到 。

尽量使用覆盖索引，减少select *

| Extra                   | 含义                                                         |
| ----------------------- | ------------------------------------------------------------ |
| Using where; UsingIndex | 查找使用了索引，但是需要的数据都在索引列中能找到，所以不需 要回表查询数据 |
| Using indexcondition    | 查找使用了索引，但是需要回表查询数据                         |

#### 排序

使用order by进行排序

##### Using filesort

通过表的索引或全表扫描，读取满足条件的数据行，然后在排序缓冲区sortbuffer中完成排序操作。

##### Using index

通过有序索引顺序扫描直接返回有序数据，不需要额外排序。

#### 设计原则

1. 针对于数据量较大，且查询比较频繁的表建立索引。
2. 尽量选择区分度高的列作为索引，尽量建立唯一索引，区分度越高，使用索引的效率越高。
3. 如果是字符串类型的字段，字段的长度较长，可以针对于字段的特点，建立前缀索引。
4. 尽量使用联合索引，减少单列索引，查询时，联合索引很多时候可以覆盖索引，节省存储空间，
   避免回表，提高查询效率。

### 6. 视图

视图（View）是一种虚拟存在的表。

#### 视图优点

* 简单：简化了用户对数据的理解和操作。

* 安全：通过视图用户只能查询和修改他们所能见到的数据

### 7. 存储过程

存储过程是指事先经过编译并存储在数据库中的一段 SQL 语句的集合。

#### 特点

* 封装，复用 -----------------------> 可以把某一业务SQL封装在存储过程中，需要用到的时候直接调用即可
* 可以接收参数，也可以返回数据 --------> 再存储过程中，可以传递参数，也可以接收返回值。
* 减少网络交互，效率提升 -------------> 如果涉及到多条SQL，每执行一次都是一次网络传输。 而如果封装在存储过程中，我们只需要网络交互一次可能就可以了。

#### 存储函数

存储函数是有返回值的存储过程。

### 8. 触发器

触发器是指在insert/update/delete之前(BEFORE)或之后(AFTER)，触发并执行触发器中定义的SQL语句集合。

### 9. 锁

锁是计算机协调多个进程或线程并发访问某一资源的机制。

在MySQL中锁按照粒度分为全局锁、表级锁、行级锁

#### 全局锁

锁定数据库中的所有表。

使用场景：对数据库做逻辑备份时，使用**全局锁**对所有的表进行锁定，数据库中的数据就不会发生变化的，这样就保证了数据的一致性和完整性。

#### 表级锁

每次操作锁住整张表。

对于表级锁，分为以下三类：

* 表锁
* 元数据锁（meta data lock，MDL）
* 意向锁

对于表锁，又分为两类：

* 表共享读锁（read lock）
* 表独占写锁（write lock）

##### 表锁

读锁不会阻塞其他客户端的读，但是会阻塞写。写锁既会阻塞其他客户端的读，又会阻塞
其他客户端的写。

##### 元数据锁

meta data lock(元数据锁)简写MDL。

元数据简单理解为一张表的表结构。

MDL是系统自动控制，无需显式使用，在访问一张表的时候会自动加上，作用是维护表元数据的数据一致性，在表上有活动事务的时候，不可以对元数据进行写入操作。为了避免DML与DDL冲突，保证读写的正确性。

##### 意向锁

作用：加表锁的时候，会根据该表上所加的意向锁来判定是否可以成功加表锁，而不用逐行判断行锁情况了，减少表锁的检查。

##### 行级锁

每次操作锁住对应的行数据。

对比：行锁的锁定粒度最小，发生锁冲突的概率最低，并发度最高。

对于行级锁，分为以下三类：

* 行锁（Record Lock）：锁定单个行记录的锁，防止其他事务对此行进行update和delete。在RC、RR隔离级别下都支持。

* 间隙锁（Gap Lock）：锁定索引记录间隙（不含该记录），确保索引记录间隙不变，防止其他事务在这个间隙进行insert，产生幻读。在RR隔离级别下都支持。

* 临键锁（Next-Key Lock）：行锁和间隙锁组合，同时锁住数据，并锁住数据前面的间隙Gap。在RR隔离级别下支持。

InnoDB实现了以下两种类型的行锁：

* 共享锁（S）：允许一个事务去读一行，阻止其他事务获得相同数据集的排它锁。
* 排他锁（X）：允许获取排他锁的事务更新数据，阻止其他事务获得相同数据集的共享锁和排他锁。

## 优化方法

### 1.性能分析

查看当前数据库的INSERT、UPDATE、DELETE、SELECT的访问频次：

```sql
-- session 是查看当前会话 ;
-- global 是查询全局数据 ;
SHOW GLOBAL STATUS LIKE 'Com_______'
```

数据库访问频次如果是以查询为主，则考虑对数据库的索引进行优化。

#### 慢查询日志

查看慢查询日志是否开启

```sql
show variables like 'slow_query_log'
```

#### profile

查看是否开启profile操作

```sql
SELECT @@profiling
```

profile的使用

```sql
-- 查看每一条SQL的耗时基本情况
show profiles;
-- 查看指定query_id的SQL语句各个阶段的耗时情况
show profile for query query_id;
-- 查看指定query_id的SQL语句CPU的使用情况
show profile cpu for query query_id;
```

#### explain

EXPLAIN 或者 DESC命令获取可 MySQL 如何执行 SELECT 语句的信息，包括在 SELECT 语句执行
过程中表如何连接和连接的顺序。

| 字段         | 含义                                                         |
| ------------ | ------------------------------------------------------------ |
| id           | select查询的序列号，表示查询中执行select子句或者是操作表的顺序 (id相同，执行顺序从上到下；  id不同，值越大，越先执行)。 |
| select_type  | 表示  SELECT 的类型，常见的取值有  SIMPLE (简单表，即不使用表连接或者子查询)、  PRIMARY (主查询，即外层的查询)、UNION ( UNION 中的第二个或者后面的查询语句)、SUBQUERY ( SELECT/WHERE之后包含了子查询)等 |
| type         | 表示连接类型，性能由好到差的连接类型为NULL、  system、const、 eq_ref、ref、range、   index、all 。 |
| possible_key | 显示可能应用在这张表上的索引，一个或多个。                   |
| key          | 实际使用的索引，如果为NULL，则没有使用索引。                 |
| key_len      | 表示索引中使用的字节数，   该值为索引字段最大可能长度，并非实际使用长 度，在不损失精确性的前提下，   长度越短越好  。 |
| rows         | MySQL认为必须要执行查询的行数，在innodb引擎的表中，是一个估计值， 可能并不总是准确的。 |
| filtered     | 表示返回结果的行数占需读取行数的百分比，   filtered 的值越大越好。 |

### 2. sql优化

#### 插入数据

优化方案：

1. 批量插入数据

2. 手动控制事务

3. 主键顺序插入

#### 主键优化

1. 满足业务需求的情况下，尽量降低主键的长度。
2. 插入数据时，尽量选择顺序插入，选择使用AUTO_INCREMENT自增主键。
3. 尽量不要使用UUID做主键或者是其他自然主键，如身份证号。
4. 业务操作时，避免对主键的修改。

#### order by优化

1. 多字段排序, 一个升序一个降序时，注意联合索引在创建时的规则（ASC/DESC）。
2. 如果不可避免的出现filesort，大数据量排序时，可以适当增大排序缓冲区大小sort_buffer_size(默认256k)。
3. 尽量使用覆盖索引。
4. 多字段排序时，遵循最左前缀法则。

#### group by优化

使用索引

#### limit优化

1. 创建覆盖索引
2. 覆盖索引加子查询

#### count优化

性能：count(*) ≈ count(1) > count(主键) > count(字段)

#### update优化

InnoDB的行锁是针对索引加的锁，不是针对记录加的锁，并且该索引不能失效，否则会从行锁升级为表锁。

## 基础sql

### DML(Data Manipulation Language)

```sql
UPDATE 表名 SET 列名1 = 值1 WHERE 列名2 = 值2
```

### DQL(Data Query Language)

```sql
SELECT COUNT(*), 列名 FROM 表名 GROUP BY 列名
```

统计表中该字段的值相等的所有**行数**并分组。

如：统计表中性别为男的行数与性别为女的**行数**
